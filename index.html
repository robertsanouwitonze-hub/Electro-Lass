<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Electro-LASS Library</title>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
    <style>
        /* (Keep all your existing CSS styles) */
        :root {
            --electro-blue: #07178c;
            --electric-orange: #ff7200;
            --neon-green: #00ffcc;
            --spark-purple: #9d00ff;
            --dark-bg: #0a0f2e;
            --text-light: #ffffff;
            --text-gray: #aaaaaa;
            --border-radius: 12px;
        }

        /* (All existing CSS remains the same until...) */

        /* ===== NEW STYLES FOR SEARCH AND COMPRESSION ===== */
        
        /* Search Bar */
        .search-container {
            margin: 2rem 0;
            position: relative;
            max-width: 800px;
            margin-left: auto;
            margin-right: auto;
        }

        .search-box {
            width: 100%;
            padding: 1rem 1.5rem;
            padding-left: 3.5rem;
            background: rgba(255, 255, 255, 0.1);
            border: 2px solid var(--neon-green);
            border-radius: 50px;
            color: var(--text-light);
            font-size: 1.1rem;
            outline: none;
            transition: all 0.3s ease;
        }

        .search-box:focus {
            background: rgba(255, 255, 255, 0.15);
            box-shadow: 0 0 20px rgba(0, 255, 204, 0.3);
        }

        .search-icon {
            position: absolute;
            left: 1.5rem;
            top: 50%;
            transform: translateY(-50%);
            color: var(--neon-green);
            font-size: 1.2rem;
        }

        /* Search Filters */
        .search-filters {
            display: flex;
            gap: 1rem;
            flex-wrap: wrap;
            margin: 1rem 0;
            padding: 1rem;
            background: rgba(7, 23, 140, 0.2);
            border-radius: var(--border-radius);
            align-items: center;
        }

        .filter-group {
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }

        .filter-group select {
            padding: 8px 12px;
            background: rgba(255, 255, 255, 0.1);
            border: 1px solid var(--electric-orange);
            border-radius: 6px;
            color: var(--text-light);
            min-width: 150px;
        }

        .search-results-info {
            margin: 1rem 0;
            padding: 1rem;
            background: rgba(0, 255, 204, 0.1);
            border-radius: var(--border-radius);
            border-left: 4px solid var(--neon-green);
        }

        /* Compression Controls */
        .compression-controls {
            background: rgba(157, 0, 255, 0.1);
            border: 1px solid var(--spark-purple);
            border-radius: var(--border-radius);
            padding: 1rem;
            margin: 1rem 0;
        }

        .compression-slider {
            width: 100%;
            margin: 1rem 0;
        }

        .compression-info {
            display: flex;
            justify-content: space-between;
            margin-top: 0.5rem;
            font-size: 0.9rem;
        }

        .compression-preview {
            margin-top: 1rem;
            padding: 1rem;
            background: rgba(0, 0, 0, 0.3);
            border-radius: 8px;
            display: none;
        }

        .compression-preview.active {
            display: block;
        }

        /* Advanced Search Modal */
        .advanced-search-modal .modal-content {
            max-width: 600px;
        }

        .search-options {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
            gap: 1rem;
            margin: 1rem 0;
        }

        .date-range {
            display: flex;
            gap: 1rem;
            align-items: center;
        }

        .date-range input {
            flex: 1;
        }

        /* Progress Indicators */
        .compression-progress {
            position: fixed;
            bottom: 20px;
            right: 20px;
            background: rgba(10, 15, 46, 0.95);
            border: 2px solid var(--neon-green);
            border-radius: var(--border-radius);
            padding: 1rem;
            width: 300px;
            z-index: 9999;
            display: none;
        }

        .compression-progress.active {
            display: block;
            animation: slideUp 0.3s ease;
        }

        @keyframes slideUp {
            from { transform: translateY(100px); opacity: 0; }
            to { transform: translateY(0); opacity: 1; }
        }

        /* Batch Upload */
        .batch-upload {
            margin: 2rem 0;
            padding: 2rem;
            background: linear-gradient(135deg, rgba(7, 23, 140, 0.3), rgba(157, 0, 255, 0.2));
            border-radius: var(--border-radius);
            border: 2px dashed var(--neon-green);
        }

        .batch-actions {
            display: flex;
            gap: 1rem;
            margin-top: 1rem;
            flex-wrap: wrap;
        }

        /* Quick Actions */
        .quick-actions {
            display: flex;
            gap: 0.5rem;
            margin: 1rem 0;
            flex-wrap: wrap;
        }

        .quick-action-btn {
            padding: 6px 12px;
            background: rgba(255, 114, 0, 0.2);
            border: 1px solid var(--electric-orange);
            border-radius: 20px;
            color: var(--text-light);
            cursor: pointer;
            font-size: 0.9rem;
            transition: all 0.3s ease;
        }

        .quick-action-btn:hover {
            background: rgba(255, 114, 0, 0.4);
        }

        /* Loading Animation */
        .loading-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.9);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 9999;
            display: none;
        }

        .loading-overlay.active {
            display: flex;
        }

        .spinner {
            width: 50px;
            height: 50px;
            border: 5px solid rgba(0, 255, 204, 0.3);
            border-top-color: var(--neon-green);
            border-radius: 50%;
            animation: spin 1s linear infinite;
            margin-bottom: 1rem;
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        /* Responsive Design */
        @media (max-width: 768px) {
            .search-filters {
                flex-direction: column;
                align-items: stretch;
            }
            
            .filter-group {
                width: 100%;
            }
            
            .filter-group select {
                width: 100%;
            }
            
            .compression-progress {
                width: calc(100% - 40px);
                left: 20px;
            }
            
            .batch-actions {
                flex-direction: column;
            }
        }
    </style>
</head>
<body>
    <!-- Navigation (Keep existing) -->
    <header class="main-header">
        <!-- Same as before -->
    </header>

    <!-- NEW: Advanced Search Modal -->
    <div class="modal advanced-search-modal" id="advancedSearchModal">
        <div class="modal-content">
            <h2><i class="fas fa-search-plus"></i> Advanced Search</h2>
            <div class="search-options">
                <div class="form-group">
                    <label><i class="fas fa-font"></i> Title Contains</label>
                    <input type="text" id="searchTitle" placeholder="Search in titles...">
                </div>
                <div class="form-group">
                    <label><i class="fas fa-user-pen"></i> Author Contains</label>
                    <input type="text" id="searchAuthor" placeholder="Search authors...">
                </div>
                <div class="form-group">
                    <label><i class="fas fa-tag"></i> Category</label>
                    <select id="searchCategory">
                        <option value="">All Categories</option>
                        <option value="General">General</option>
                        <option value="Programming">Programming</option>
                        <option value="Technology">Technology</option>
                        <option value="Science">Science</option>
                        <option value="Fiction">Fiction</option>
                        <option value="Educational">Educational</option>
                    </select>
                </div>
                <div class="form-group">
                    <label><i class="fas fa-calendar"></i> Date Range</label>
                    <div class="date-range">
                        <input type="date" id="searchDateFrom" placeholder="From">
                        <span>to</span>
                        <input type="date" id="searchDateTo" placeholder="To">
                    </div>
                </div>
                <div class="form-group">
                    <label><i class="fas fa-file-pdf"></i> Has PDF</label>
                    <select id="searchHasPDF">
                        <option value="">Any</option>
                        <option value="yes">With PDF</option>
                        <option value="no">Without PDF</option>
                    </select>
                </div>
                <div class="form-group">
                    <label><i class="fas fa-sort-amount-down"></i> Sort By</label>
                    <select id="searchSortBy">
                        <option value="newest">Newest First</option>
                        <option value="oldest">Oldest First</option>
                        <option value="title_asc">Title (A-Z)</option>
                        <option value="title_desc">Title (Z-A)</option>
                        <option value="author">Author</option>
                    </select>
                </div>
            </div>
            <div style="display: flex; gap: 10px; margin-top: 1rem;">
                <button class="btn btn-primary" onclick="performAdvancedSearch()">
                    <i class="fas fa-search"></i> Search
                </button>
                <button class="btn" onclick="resetAdvancedSearch()">
                    <i class="fas fa-redo"></i> Reset
                </button>
                <button class="btn" onclick="closeModal('advancedSearchModal')">
                    <i class="fas fa-times"></i> Cancel
                </button>
            </div>
        </div>
    </div>

    <!-- NEW: Batch Upload Modal -->
    <div class="modal" id="batchUploadModal">
        <div class="modal-content">
            <h2><i class="fas fa-upload"></i> Batch Upload Books</h2>
            <div class="compression-controls" style="margin-top: 1rem;">
                <label style="display: block; margin-bottom: 0.5rem;">
                    <i class="fas fa-compress-arrows-alt"></i> Compression Level (Higher = Smaller Files)
                </label>
                <input type="range" min="0" max="100" value="50" class="compression-slider" id="batchCompression">
                <div class="compression-info">
                    <span>Fast (Low Compression)</span>
                    <span id="batchCompressionValue">50%</span>
                    <span>Small (High Compression)</span>
                </div>
                <div class="form-group">
                    <label>Default Category for All Books</label>
                    <select id="batchCategory">
                        <option value="General">General</option>
                        <option value="Programming">Programming</option>
                        <option value="Technology">Technology</option>
                        <option value="Science">Science</option>
                        <option value="Fiction">Fiction</option>
                        <option value="Educational">Educational</option>
                    </select>
                </div>
            </div>
            <div class="form-group">
                <label><i class="fas fa-file-pdf"></i> Select Multiple PDF Files</label>
                <input type="file" id="batchFiles" accept=".pdf" multiple style="width: 100%; padding: 12px;">
                <small style="color: var(--text-gray);">Hold Ctrl/Cmd to select multiple files (max 50 files)</small>
            </div>
            <div id="batchFileList" style="margin: 1rem 0; max-height: 200px; overflow-y: auto;"></div>
            <div class="upload-progress" id="batchUploadProgress">
                <div style="display: flex; justify-content: space-between; margin-bottom: 0.5rem;">
                    <span>Processing files...</span>
                    <span id="batchUploadPercentage">0%</span>
                </div>
                <div class="progress-bar">
                    <div class="progress-fill" id="batchUploadProgressBar"></div>
                </div>
                <div id="batchStatus" style="margin-top: 0.5rem; font-size: 0.9rem;"></div>
            </div>
            <div style="display: flex; gap: 10px; margin-top: 1rem;">
                <button class="btn btn-primary" onclick="processBatchUpload()" id="batchUploadBtn">
                    <i class="fas fa-play"></i> Start Batch Upload
                </button>
                <button class="btn" onclick="closeModal('batchUploadModal')">
                    <i class="fas fa-times"></i> Cancel
                </button>
            </div>
        </div>
    </div>

    <!-- NEW: Global Search Bar -->
    <div class="search-container" id="globalSearchContainer" style="display: none;">
        <div class="search-icon">
            <i class="fas fa-search"></i>
        </div>
        <input type="text" class="search-box" id="globalSearch" placeholder="Search books by title, author, or category...">
        <div class="quick-actions">
            <button class="quick-action-btn" onclick="openAdvancedSearch()">
                <i class="fas fa-sliders-h"></i> Advanced
            </button>
            <button class="quick-action-btn" onclick="searchByCategory('Programming')">
                <i class="fas fa-code"></i> Programming
            </button>
            <button class="quick-action-btn" onclick="searchByCategory('Technology')">
                <i class="fas fa-microchip"></i> Technology
            </button>
            <button class="quick-action-btn" onclick="showNewBooks()">
                <i class="fas fa-bolt"></i> New Arrivals
            </button>
        </div>
    </div>

    <!-- NEW: Compression Progress Indicator -->
    <div class="compression-progress" id="compressionProgress">
        <h4><i class="fas fa-compress-arrows-alt"></i> Compressing Files</h4>
        <div style="display: flex; justify-content: space-between; margin: 0.5rem 0;">
            <span id="compressionCurrentFile">Processing...</span>
            <span id="compressionFileProgress">0%</span>
        </div>
        <div class="progress-bar">
            <div class="progress-fill" id="compressionOverallProgress"></div>
        </div>
        <div style="display: flex; justify-content: space-between; margin-top: 0.5rem; font-size: 0.9rem;">
            <span id="compressionStats">Size: 0MB â†’ 0MB</span>
            <span id="compressionTime">Time: 0s</span>
        </div>
    </div>

    <!-- NEW: Loading Overlay -->
    <div class="loading-overlay" id="loadingOverlay">
        <div class="spinner"></div>
        <h3 id="loadingText">Processing...</h3>
        <p id="loadingSubtext" style="color: var(--text-gray); margin-top: 0.5rem;"></p>
    </div>

    <!-- Main Content -->
    <main id="pageContainer">
        <!-- Pages load here -->
    </main>

    <!-- (Keep all existing modals) -->

    <script>
        // ===== ENHANCED STORAGE WITH COMPRESSION =====
        class EnhancedPDFStorage {
            constructor() {
                this.dbName = 'ElectroLASS_Enhanced';
                this.storeName = 'compressedPDFs';
                this.db = null;
                this.MAX_SIZE = 100 * 1024 * 1024 * 1024; // 100GB
            }
            
            async init() {
                return new Promise((resolve, reject) => {
                    const request = indexedDB.open(this.dbName, 4);
                    
                    request.onerror = reject;
                    
                    request.onsuccess = (event) => {
                        this.db = event.target.result;
                        resolve(this.db);
                    };
                    
                    request.onupgradeneeded = (event) => {
                        const db = event.target.result;
                        
                        // Create stores if they don't exist
                        const stores = [
                            'pdfs', 'books', 'users', 'searchIndex', 
                            'compressedPDFs', 'metadata', 'categories'
                        ];
                        
                        stores.forEach(storeName => {
                            if (!db.objectStoreNames.contains(storeName)) {
                                const store = db.createObjectStore(storeName, { keyPath: 'id' });
                                
                                // Add indexes for search
                                if (storeName === 'books') {
                                    store.createIndex('title', 'title', { unique: false });
                                    store.createIndex('author', 'author', { unique: false });
                                    store.createIndex('category', 'category', { unique: false });
                                    store.createIndex('dateAdded', 'dateAdded', { unique: false });
                                    store.createIndex('searchable', 'searchable', { unique: false });
                                }
                            }
                        });
                    };
                });
            }
            
            // ===== COMPRESSION FUNCTIONS =====
            async compressPDF(file, quality = 50) {
                return new Promise((resolve, reject) => {
                    const reader = new FileReader();
                    
                    reader.onload = async (event) => {
                        try {
                            const arrayBuffer = event.target.result;
                            
                            // Simple compression - in real app, use PDF.js or similar
                            // For demo, we'll simulate compression
                            const compressedSize = Math.max(
                                1024, // Minimum 1KB
                                file.size * (1 - (quality / 200)) // Simulate compression ratio
                            );
                            
                            // Create compressed blob (simulated)
                            const compressedBlob = new Blob(
                                [await this.simulateCompression(arrayBuffer, quality)],
                                { type: 'application/pdf' }
                            );
                            
                            resolve({
                                blob: compressedBlob,
                                originalSize: file.size,
                                compressedSize: compressedBlob.size,
                                compressionRatio: (file.size - compressedBlob.size) / file.size * 100,
                                quality: quality
                            });
                        } catch (error) {
                            reject(error);
                        }
                    };
                    
                    reader.onerror = reject;
                    reader.readAsArrayBuffer(file);
                });
            }
            
            async simulateCompression(arrayBuffer, quality) {
                // Simulate compression - in production, use:
                // 1. PDF.js for PDF manipulation
                // 2. Canvas for image compression
                // 3. Text compression algorithms
                
                // For demo, just return the original
                return arrayBuffer;
            }
            
            async saveCompressedPDF(bookId, pdfFile, compressionLevel = 50) {
                try {
                    // Show compression progress
                    updateCompressionProgress(0, `Starting compression: ${pdfFile.name}`);
                    
                    // Compress the PDF
                    const compressed = await this.compressPDF(pdfFile, compressionLevel);
                    
                    updateCompressionProgress(50, `Saving compressed file...`);
                    
                    // Save to IndexedDB
                    await this.saveToIndexedDB(bookId, compressed.blob, {
                        originalSize: compressed.originalSize,
                        compressedSize: compressed.compressedSize,
                        compressionRatio: compressed.compressionRatio,
                        quality: compressionLevel,
                        uploadDate: new Date().toISOString()
                    });
                    
                    updateCompressionProgress(100, `Compression complete!`);
                    
                    return {
                        success: true,
                        pdfId: bookId,
                        stats: {
                            originalSize: compressed.originalSize,
                            compressedSize: compressed.compressedSize,
                            savings: compressed.compressionRatio.toFixed(1) + '%'
                        }
                    };
                } catch (error) {
                    console.error('Compression error:', error);
                    throw error;
                }
            }
            
            async saveToIndexedDB(key, blob, metadata) {
                return new Promise((resolve, reject) => {
                    const transaction = this.db.transaction([this.storeName], 'readwrite');
                    const store = transaction.objectStore(this.storeName);
                    
                    const data = {
                        id: key,
                        blob: blob,
                        metadata: metadata,
                        timestamp: Date.now()
                    };
                    
                    const request = store.put(data);
                    
                    request.onsuccess = () => resolve(true);
                    request.onerror = (event) => reject(event.target.error);
                });
            }
            
            // ===== SEARCH FUNCTIONS =====
            async buildSearchIndex() {
                const books = await this.getAllBooks();
                const searchIndex = [];
                
                books.forEach(book => {
                    // Create searchable text
                    const searchableText = `
                        ${book.title || ''} 
                        ${book.author || ''} 
                        ${book.category || ''} 
                        ${book.description || ''}
                    `.toLowerCase().trim();
                    
                    // Add to search index
                    searchIndex.push({
                        id: book.id,
                        title: book.title,
                        author: book.author,
                        category: book.category,
                        searchable: searchableText,
                        score: 0
                    });
                });
                
                // Save search index
                await this.saveSearchIndex(searchIndex);
                return searchIndex;
            }
            
            async saveSearchIndex(index) {
                return new Promise((resolve, reject) => {
                    const transaction = this.db.transaction(['searchIndex'], 'readwrite');
                    const store = transaction.objectStore('searchIndex');
                    
                    // Clear existing index
                    store.clear();
                    
                    // Add new entries
                    index.forEach(item => {
                        store.add(item);
                    });
                    
                    transaction.oncomplete = () => resolve(true);
                    transaction.onerror = (event) => reject(event.target.error);
                });
            }
            
            async searchBooks(query, filters = {}) {
                const books = await this.getAllBooks();
                
                if (!query && Object.keys(filters).length === 0) {
                    return books;
                }
                
                const searchTerms = query ? query.toLowerCase().split(/\s+/) : [];
                
                return books.filter(book => {
                    let score = 0;
                    
                    // Text search
                    if (searchTerms.length > 0) {
                        const searchableText = `
                            ${book.title || ''} ${book.author || ''} 
                            ${book.category || ''} ${book.description || ''}
                        `.toLowerCase();
                        
                        searchTerms.forEach(term => {
                            if (searchableText.includes(term)) {
                                score += 10;
                                
                                // Bonus points for title matches
                                if (book.title && book.title.toLowerCase().includes(term)) {
                                    score += 20;
                                }
                                
                                // Bonus for author matches
                                if (book.author && book.author.toLowerCase().includes(term)) {
                                    score += 15;
                                }
                            }
                        });
                    }
                    
                    // Apply filters
                    if (filters.category && book.category !== filters.category) {
                        return false;
                    }
                    
                    if (filters.hasPDF !== undefined) {
                        const hasPDF = !!book.hasPdf;
                        if (filters.hasPDF === 'yes' && !hasPDF) return false;
                        if (filters.hasPDF === 'no' && hasPDF) return false;
                    }
                    
                    if (filters.dateFrom && book.dateAdded) {
                        const bookDate = new Date(book.dateAdded);
                        const filterDate = new Date(filters.dateFrom);
                        if (bookDate < filterDate) return false;
                    }
                    
                    if (filters.dateTo && book.dateAdded) {
                        const bookDate = new Date(book.dateAdded);
                        const filterDate = new Date(filters.dateTo);
                        if (bookDate > filterDate) return false;
                    }
                    
                    book.searchScore = score;
                    return score > 0 || Object.keys(filters).length > 0;
                }).sort((a, b) => {
                    // Sort by search score, then by date
                    if (a.searchScore !== b.searchScore) {
                        return b.searchScore - a.searchScore;
                    }
                    return new Date(b.dateAdded) - new Date(a.dateAdded);
                });
            }
            
            // ===== BATCH OPERATIONS =====
            async batchUpload(files, options = {}) {
                const results = {
                    successful: [],
                    failed: [],
                    totalSize: 0,
                    compressedSize: 0
                };
                
                for (let i = 0; i < files.length; i++) {
                    const file = files[i];
                    const bookId = Date.now() + i;
                    
                    try {
                        updateBatchProgress(i, files.length, `Processing: ${file.name}`);
                        
                        // Create book metadata
                        const book = {
                            id: bookId,
                            title: file.name.replace('.pdf', '').replace(/_/g, ' '),
                            author: options.defaultAuthor || 'Unknown',
                            category: options.defaultCategory || 'General',
                            description: `Uploaded batch file: ${file.name}`,
                            hasPdf: true,
                            pdfId: `batch_${bookId}`,
                            dateAdded: new Date().toLocaleDateString(),
                            addedBy: currentUser.name || 'Admin',
                            uploadDate: new Date().toISOString(),
                            fileSize: this.formatBytes(file.size),
                            batchUpload: true,
                            batchId: options.batchId || Date.now()
                        };
                        
                        // Compress and save PDF
                        const compressionResult = await this.saveCompressedPDF(
                            bookId, 
                            file, 
                            options.compressionLevel || 50
                        );
                        
                        // Update book with compression info
                        book.compressionInfo = {
                            originalSize: compressionResult.stats.originalSize,
                            compressedSize: compressionResult.stats.compressedSize,
                            savings: compressionResult.stats.savings
                        };
                        
                        // Save book metadata
                        await this.saveBook(book);
                        
                        results.successful.push(book);
                        results.totalSize += file.size;
                        results.compressedSize += compressionResult.stats.compressedSize;
                        
                    } catch (error) {
                        results.failed.push({
                            fileName: file.name,
                            error: error.message
                        });
                    }
                }
                
                return results;
            }
            
            // ===== HELPER METHODS =====
            async saveBook(book) {
                return new Promise((resolve, reject) => {
                    const transaction = this.db.transaction(['books'], 'readwrite');
                    const store = transaction.objectStore('books');
                    store.put(book);
                    transaction.oncomplete = () => resolve(true);
                    transaction.onerror = reject;
                });
            }
            
            async getAllBooks() {
                return new Promise((resolve, reject) => {
                    const transaction = this.db.transaction(['books'], 'readonly');
                    const store = transaction.objectStore('books');
                    const request = store.getAll();
                    request.onsuccess = (event) => resolve(event.target.result || []);
                    request.onerror = reject;
                });
            }
            
            async getBook(id) {
                return new Promise((resolve, reject) => {
                    const transaction = this.db.transaction(['books'], 'readonly');
                    const store = transaction.objectStore('books');
                    const request = store.get(id);
                    request.onsuccess = (event) => resolve(event.target.result);
                    request.onerror = reject;
                });
            }
            
            async deleteBook(id) {
                return new Promise((resolve, reject) => {
                    const transaction = this.db.transaction(['books'], 'readwrite');
                    const store = transaction.objectStore('books');
                    store.delete(id);
                    transaction.oncomplete = () => resolve(true);
                    transaction.onerror = reject;
                });
            }
            
            async getStorageStats() {
                const books = await this.getAllBooks();
                let totalOriginalSize = 0;
                let totalCompressedSize = 0;
                
                books.forEach(book => {
                    if (book.compressionInfo) {
                        totalOriginalSize += book.compressionInfo.originalSize || 0;
                        totalCompressedSize += book.compressionInfo.compressedSize || 0;
                    }
                });
                
                return {
                    totalBooks: books.length,
                    totalOriginalSize,
                    totalCompressedSize,
                    spaceSaved: totalOriginalSize - totalCompressedSize,
                    compressionRate: totalOriginalSize > 0 ? 
                        ((totalOriginalSize - totalCompressedSize) / totalOriginalSize * 100).toFixed(1) : 0
                };
            }
            
            formatBytes(bytes, decimals = 2) {
                if (bytes === 0) return '0 Bytes';
                const k = 1024;
                const dm = decimals < 0 ? 0 : decimals;
                const sizes = ['Bytes', 'KB', 'MB', 'GB', 'TB'];
                const i = Math.floor(Math.log(bytes) / Math.log(k));
                return parseFloat((bytes / Math.pow(k, i)).toFixed(dm)) + ' ' + sizes[i];
            }
        }

        // ===== SEARCH AND UI FUNCTIONS =====
        let storage = null;
        let currentSearchResults = [];
        let searchTimeout = null;

        function initializeSearch() {
            // Add search to library page
            const searchHTML = `
                <div class="search-container" id="mainSearchContainer">
                    <div class="search-icon">
                        <i class="fas fa-search"></i>
                    </div>
                    <input type="text" class="search-box" id="mainSearch" 
                           placeholder="Search ${books.length} books by title, author, or category..."
                           oninput="handleSearchInput(this.value)">
                    <div class="search-filters">
                        <div class="filter-group">
                            <label><i class="fas fa-tag"></i> Category:</label>
                            <select id="filterCategory" onchange="applyFilters()">
                                <option value="">All Categories</option>
                                <option value="General">General</option>
                                <option value="Programming">Programming</option>
                                <option value="Technology">Technology</option>
                                <option value="Science">Science</option>
                                <option value="Fiction">Fiction</option>
                                <option value="Educational">Educational</option>
                            </select>
                        </div>
                        <div class="filter-group">
                            <label><i class="fas fa-file-pdf"></i> PDF:</label>
                            <select id="filterPDF" onchange="applyFilters()">
                                <option value="">All Books</option>
                                <option value="yes">With PDF</option>
                                <option value="no">Without PDF</option>
                            </select>
                        </div>
                        <div class="filter-group">
                            <label><i class="fas fa-sort"></i> Sort:</label>
                            <select id="filterSort" onchange="applyFilters()">
                                <option value="relevance">Relevance</option>
                                <option value="newest">Newest First</option>
                                <option value="oldest">Oldest First</option>
                                <option value="title_asc">Title A-Z</option>
                                <option value="title_desc">Title Z-A</option>
                            </select>
                        </div>
                        <button class="btn" onclick="openAdvancedSearch()" style="margin-left: auto;">
                            <i class="fas fa-sliders-h"></i> Advanced
                        </button>
                    </div>
                </div>
                <div id="searchResultsInfo" class="search-results-info" style="display: none;">
                    <div style="display: flex; justify-content: space-between; align-items: center;">
                        <span id="resultsCount">0 results</span>
                        <button class="btn" onclick="clearSearch()" style="padding: 5px 10px;">
                            <i class="fas fa-times"></i> Clear Search
                        </button>
                    </div>
                </div>
            `;
            
            // Insert search into library page
            const libraryContainer = document.getElementById('pageContainer');
            if (libraryContainer && libraryContainer.innerHTML.includes('Digital Library')) {
                const controls = document.getElementById('libraryControls');
                if (controls) {
                    controls.insertAdjacentHTML('afterend', searchHTML);
                }
            }
        }

        async function handleSearchInput(query) {
            clearTimeout(searchTimeout);
            
            searchTimeout = setTimeout(async () => {
                if (!storage) return;
                
                showLoading('Searching books...');
                
                try {
                    const filters = getCurrentFilters();
                    currentSearchResults = await storage.searchBooks(query, filters);
                    
                    displaySearchResults(currentSearchResults);
                    
                    // Update results info
                    const resultsInfo = document.getElementById('searchResultsInfo');
                    const resultsCount = document.getElementById('resultsCount');
                    
                    if (resultsInfo && resultsCount) {
                        resultsInfo.style.display = 'block';
                        resultsCount.textContent = `${currentSearchResults.length} result${currentSearchResults.length !== 1 ? 's' : ''} found`;
                        
                        if (query) {
                            resultsCount.innerHTML += ` for "<strong>${query}</strong>"`;
                        }
                    }
                } catch (error) {
                    console.error('Search error:', error);
                    showAlert('Search failed: ' + error.message, 'error');
                } finally {
                    hideLoading();
                }
            }, 300);
        }

        function getCurrentFilters() {
            const filters = {};
            
            const category = document.getElementById('filterCategory');
            const pdfFilter = document.getElementById('filterPDF');
            
            if (category && category.value) filters.category = category.value;
            if (pdfFilter && pdfFilter.value) filters.hasPDF = pdfFilter.value;
            
            return filters;
        }

        function applyFilters() {
            const query = document.getElementById('mainSearch')?.value || '';
            handleSearchInput(query);
        }

        function displaySearchResults(results) {
            const container = document.getElementById('booksContainer');
            if (!container) return;
            
            if (results.length === 0) {
                container.innerHTML = `
                    <div style="text-align: center; padding: 3rem; grid-column: 1 / -1;">
                        <i class="fas fa-search" style="font-size: 4rem; color: var(--text-gray); margin-bottom: 1rem;"></i>
                        <h3>No books found</h3>
                        <p>Try different search terms or filters</p>
                        <button class="btn" onclick="clearSearch()" style="margin-top: 1rem;">
                            <i class="fas fa-redo"></i> Clear Search
                        </button>
                    </div>
                `;
                return;
            }
            
            // Sort results
            const sortBy = document.getElementById('filterSort')?.value || 'relevance';
            results.sort((a, b) => {
                switch (sortBy) {
                    case 'newest':
                        return new Date(b.dateAdded) - new Date(a.dateAdded);
                    case 'oldest':
                        return new Date(a.dateAdded) - new Date(b.dateAdded);
                    case 'title_asc':
                        return (a.title || '').localeCompare(b.title || '');
                    case 'title_desc':
                        return (b.title || '').localeCompare(a.title || '');
                    default: // relevance
                        return (b.searchScore || 0) - (a.searchScore || 0);
                }
            });
            
            let booksHTML = '<div class="books-grid">';
            
            results.forEach(book => {
                const isRecent = isNewBook(book.id);
                booksHTML += `
                    <div class="book-card">
                        <div class="book-cover">
                            <i class="fas fa-book"></i>
                            ${book.hasPdf ? '<div class="pdf-badge">PDF</div>' : ''}
                            ${isRecent ? '<div class="pdf-badge" style="background: var(--neon-green); top: 40px;">NEW</div>' : ''}
                            ${book.compressionInfo ? '<div class="pdf-badge" style="background: var(--spark-purple); top: 70px; font-size: 0.7rem;">COMPRESSED</div>' : ''}
                        </div>
                        <h3 class="book-title">${book.title}</h3>
                        <div class="book-details">
                            <p><strong><i class="fas fa-user-pen"></i> Author:</strong> ${book.author}</p>
                            <p><strong><i class="fas fa-tag"></i> Category:</strong> ${book.category}</p>
                            ${book.description ? `<p style="font-size: 0.9rem; line-height: 1.4;">${book.description}</p>` : ''}
                            <p><small><i class="fas fa-calendar"></i> Added: ${book.dateAdded}</small></p>
                            ${book.compressionInfo ? `
                                <p><small><i class="fas fa-compress-arrows-alt"></i> Compressed: ${book.compressionInfo.savings} saved</small></p>
                            ` : ''}
                        </div>
                        <div class="book-actions">
                            ${book.hasPdf ? `
                                <button class="btn" onclick="openPDFViewer(${book.id})" style="background: #ff3860; color: white; flex: 1;">
                                    <i class="fas fa-file-pdf"></i> Read PDF
                                </button>
                            ` : `
                                <button class="btn" style="background: var(--electric-orange); color: white; flex: 1;">
                                    <i class="fas fa-book-open"></i> View Details
                                </button>
                            `}
                            ${currentUser.role === 'admin' ? `
                                <button class="btn" onclick="deleteBook(${book.id})" style="background: #333; color: white;">
                                    <i class="fas fa-trash"></i>
                                </button>
                            ` : ''}
                        </div>
                    </div>
                `;
            });
            
            booksHTML += '</div>';
            container.innerHTML = booksHTML;
        }

        function clearSearch() {
            const searchInput = document.getElementById('mainSearch');
            const resultsInfo = document.getElementById('searchResultsInfo');
            
            if (searchInput) searchInput.value = '';
            if (resultsInfo) resultsInfo.style.display = 'none';
            
            // Reset filters
            const category = document.getElementById('filterCategory');
            const pdfFilter = document.getElementById('filterPDF');
            const sort = document.getElementById('filterSort');
            
            if (category) category.value = '';
            if (pdfFilter) pdfFilter.value = '';
            if (sort) sort.value = 'relevance';
            
            // Load all books
            loadBooks();
        }

        // ===== ADVANCED SEARCH FUNCTIONS =====
        function openAdvancedSearch() {
            document.getElementById('advancedSearchModal').style.display = 'flex';
        }

        async function performAdvancedSearch() {
            const title = document.getElementById('searchTitle').value;
            const author = document.getElementById('searchAuthor').value;
            const category = document.getElementById('searchCategory').value;
            const dateFrom = document.getElementById('searchDateFrom').value;
            const dateTo = document.getElementById('searchDateTo').value;
            const hasPDF = document.getElementById('searchHasPDF').value;
            const sortBy = document.getElementById('searchSortBy').value;
            
            // Build query from all fields
            let query = '';
            if (title) query += ` ${title}`;
            if (author) query += ` ${author}`;
            
            // Build filters
            const filters = {};
            if (category) filters.category = category;
            if (hasPDF) filters.hasPDF = hasPDF;
            if (dateFrom) filters.dateFrom = dateFrom;
            if (dateTo) filters.dateTo = dateTo;
            
            // Perform search
            if (storage) {
                currentSearchResults = await storage.searchBooks(query.trim(), filters);
                
                // Apply sorting
                currentSearchResults.sort((a, b) => {
                    switch (sortBy) {
                        case 'newest':
                            return new Date(b.dateAdded) - new Date(a.dateAdded);
                        case 'oldest':
                            return new Date(a.dateAdded) - new Date(b.dateAdded);
                        case 'title_asc':
                            return (a.title || '').localeCompare(b.title || '');
                        case 'title_desc':
                            return (b.title || '').localeCompare(a.title || '');
                        case 'author':
                            return (a.author || '').localeCompare(b.author || '');
                        default:
                            return 0;
                    }
                });
                
                displaySearchResults(currentSearchResults);
                
                // Update main search
                const mainSearch = document.getElementById('mainSearch');
                if (mainSearch) mainSearch.value = query.trim();
                
                // Update filters
                updateMainFilters(category, hasPDF);
                
                closeModal('advancedSearchModal');
                showAlert(`Found ${currentSearchResults.length} books`, 'success');
            }
        }

        function resetAdvancedSearch() {
            document.getElementById('searchTitle').value = '';
            document.getElementById('searchAuthor').value = '';
            document.getElementById('searchCategory').value = '';
            document.getElementById('searchDateFrom').value = '';
            document.getElementById('searchDateTo').value = '';
            document.getElementById('searchHasPDF').value = '';
            document.getElementById('searchSortBy').value = 'newest';
        }

        function updateMainFilters(category, hasPDF) {
            const catFilter = document.getElementById('filterCategory');
            const pdfFilter = document.getElementById('filterPDF');
            
            if (catFilter && category) catFilter.value = category;
            if (pdfFilter && hasPDF) pdfFilter.value = hasPDF;
        }

        // ===== QUICK SEARCH FUNCTIONS =====
        function searchByCategory(category) {
            const searchInput = document.getElementById('mainSearch');
            if (searchInput) {
                searchInput.value = category;
                handleSearchInput(category);
            }
        }

        function showNewBooks() {
            const sevenDaysAgo = new Date();
            sevenDaysAgo.setDate(sevenDaysAgo.getDate() - 7);
            
            // This would filter by date in a real implementation
            // For now, just show a message
            showAlert('Showing books added in the last 7 days', 'info');
            
            // You could implement date-based filtering here
            const searchInput = document.getElementById('mainSearch');
            if (searchInput) {
                searchInput.value = 'new arrivals';
                handleSearchInput('new');
            }
        }

        // ===== COMPRESSION FUNCTIONS =====
        function updateCompressionProgress(percent, message = '') {
            const progress = document.getElementById('compressionProgress');
            const currentFile = document.getElementById('compressionCurrentFile');
            const fileProgress = document.getElementById('compressionFileProgress');
            const overallProgress = document.getElementById('compressionOverallProgress');
            
            if (progress && currentFile && fileProgress && overallProgress) {
                progress.classList.add('active');
                currentFile.textContent = message;
                fileProgress.textContent = `${percent}%`;
                overallProgress.style.width = `${percent}%`;
                
                // Auto-hide when complete
                if (percent >= 100) {
                    setTimeout(() => {
                        progress.classList.remove('active');
                    }, 2000);
                }
            }
        }

        // ===== BATCH UPLOAD FUNCTIONS =====
        function openBatchUpload() {
            document.getElementById('batchUploadModal').style.display = 'flex';
            
            // Setup file list display
            document.getElementById('batchFiles').addEventListener('change', function(e) {
                const files = e.target.files;
                const fileList = document.getElementById('batchFileList');
                
                if (files.length > 0) {
                    let html = '<h4>Selected Files:</h4><ul style="list-style: none; padding-left: 0;">';
                    
                    for (let i = 0; i < Math.min(files.length, 10); i++) {
                        const file = files[i];
                        const sizeMB = (file.size / (1024 * 1024)).toFixed(2);
                        html += `
                            <li style="padding: 5px 0; border-bottom: 1px solid rgba(255,255,255,0.1);">
                                <i class="fas fa-file-pdf"></i> ${file.name} 
                                <span style="color: var(--text-gray); font-size: 0.9rem;">(${sizeMB} MB)</span>
                            </li>
                        `;
                    }
                    
                    if (files.length > 10) {
                        html += `<li style="padding: 5px 0; color: var(--neon-green);">
                            ...and ${files.length - 10} more files
                        </li>`;
                    }
                    
                    html += '</ul>';
                    fileList.innerHTML = html;
                } else {
                    fileList.innerHTML = '';
                }
            });
            
            // Setup compression slider
            document.getElementById('batchCompression').addEventListener('input', function(e) {
                document.getElementById('batchCompressionValue').textContent = `${e.target.value}%`;
            });
        }

        async function processBatchUpload() {
            const files = document.getElementById('batchFiles').files;
            const compressionLevel = parseInt(document.getElementById('batchCompression').value);
            const defaultCategory = document.getElementById('batchCategory').value;
            
            if (files.length === 0) {
                showAlert('Please select files to upload', 'error');
                return;
            }
            
            if (files.length > 50) {
                showAlert('Maximum 50 files per batch', 'error');
                return;
            }
            
            // Disable button and show progress
            const uploadBtn = document.getElementById('batchUploadBtn');
            uploadBtn.disabled = true;
            uploadBtn.innerHTML = '<i class="fas fa-spinner fa-spin"></i> Processing...';
            
            const progress = document.getElementById('batchUploadProgress');
            progress.classList.add('active');
            
            try {
                showLoading(`Processing ${files.length} files...`);
                
                const options = {
                    compressionLevel: compressionLevel,
                    defaultCategory: defaultCategory,
                    batchId: Date.now()
                };
                
                // Process batch upload
                const results = await storage.batchUpload(files, options);
                
                // Update progress
                updateBatchProgress(files.length, files.length, 'Complete!');
                
                // Show results
                const totalSaved = storage.formatBytes(results.totalSize - results.compressedSize);
                const savingsPercent = results.totalSize > 0 ? 
                    ((results.totalSize - results.compressedSize) / results.totalSize * 100).toFixed(1) : 0;
                
                document.getElementById('batchStatus').innerHTML = `
                    <div style="color: var(--neon-green);">
                        <i class="fas fa-check-circle"></i> Upload Complete!
                    </div>
                    <div style="margin-top: 5px; font-size: 0.9rem;">
                        <strong>${results.successful.length}</strong> files uploaded successfully<br>
                        ${results.failed.length > 0 ? `<strong>${results.failed.length}</strong> files failed<br>` : ''}
                        Space saved: <strong>${totalSaved}</strong> (${savingsPercent}%)
                    </div>
                `;
                
                // Show summary alert
                let alertMsg = `âœ… Batch upload complete!<br>
                    â€¢ Success: ${results.successful.length} files<br>
                    â€¢ Failed: ${results.failed.length} files<br>
                    â€¢ Space saved: ${totalSaved}`;
                
                if (results.failed.length > 0) {
                    alertMsg += `<br><br>Failed files:<br>`;
                    results.failed.forEach((fail, index) => {
                        if (index < 5) {
                            alertMsg += `â€¢ ${fail.fileName}: ${fail.error}<br>`;
                        }
                    });
                    if (results.failed.length > 5) {
                        alertMsg += `â€¢ ...and ${results.failed.length - 5} more`;
                    }
                }
                
                showAlert(alertMsg, results.failed.length === 0 ? 'success' : 'warning');
                
                // Refresh books display
                await loadBooks();
                
                // Close modal after delay
                setTimeout(() => {
                    closeModal('batchUploadModal');
                    // Reset form
                    document.getElementById('batchFiles').value = '';
                    document.getElementById('batchFileList').innerHTML = '';
                    document.getElementById('batchStatus').innerHTML = '';
                    progress.classList.remove('active');
                    
                    uploadBtn.disabled = false;
                    uploadBtn.innerHTML = '<i class="fas fa-play"></i> Start Batch Upload';
                }, 3000);
                
            } catch (error) {
                showAlert('Batch upload failed: ' + error.message, 'error');
                
                uploadBtn.disabled = false;
                uploadBtn.innerHTML = '<i class="fas fa-play"></i> Start Batch Upload';
                progress.classList.remove('active');
            } finally {
                hideLoading();
            }
        }

        function updateBatchProgress(current, total, message) {
            const percent = Math.round((current / total) * 100);
            document.getElementById('batchUploadPercentage').textContent = `${percent}%`;
            document.getElementById('batchUploadProgressBar').style.width = `${percent}%`;
            
            if (message) {
                const status = document.getElementById('batchStatus');
                if (status) {
                    status.textContent = message;
                }
            }
        }

        // ===== LOADING FUNCTIONS =====
        function showLoading(message = 'Loading...', subtext = '') {
            const overlay = document.getElementById('loadingOverlay');
            const text = document.getElementById('loadingText');
            const subtextEl = document.getElementById('loadingSubtext');
            
            if (overlay && text) {
                overlay.classList.add('active');
                text.textContent = message;
                if (subtextEl && subtext) {
                    subtextEl.textContent = subtext;
                }
            }
        }

        function hideLoading() {
            const overlay = document.getElementById('loadingOverlay');
            if (overlay) {
                overlay.classList.remove('active');
            }
        }

        // ===== INITIALIZATION =====
        async function initializeEnhancedStorage() {
            try {
                showLoading('Initializing storage system...');
                
                storage = new EnhancedPDFStorage();
                await storage.init();
                
                // Migrate existing data if needed
                await migrateToEnhancedStorage();
                
                // Build search index
                showLoading('Building search index...');
                await storage.buildSearchIndex();
                
                hideLoading();
                console.log('Enhanced storage initialized');
                
                // Initialize search UI
                setTimeout(initializeSearch, 100);
                
            } catch (error) {
                console.error('Storage initialization failed:', error);
                showAlert('Storage system error. Please refresh the page.', 'error');
                hideLoading();
            }
        }

        async function migrateToEnhancedStorage() {
            // Check if we have old localStorage data
            const oldBooks = JSON.parse(localStorage.getItem('libraryBooks') || '[]');
            
            if (oldBooks.length > 0) {
                showLoading(`Migrating ${oldBooks.length} books...`);
                
                for (const book of oldBooks) {
                    try {
                        await storage.saveBook(book);
                    } catch (error) {
                        console.error('Migration error for book:', book.title, error);
                    }
                }
                
                // Clear old storage
                localStorage.removeItem('libraryBooks');
                
                console.log('Migration complete');
            }
        }

        // ===== UPDATE EXISTING FUNCTIONS =====
        async function loadBooks() {
            const container = document.getElementById('booksContainer');
            if (!container || !storage) return;
            
            try {
                showLoading('Loading books...');
                
                const allBooks = await storage.getAllBooks();
                
                if (allBooks.length === 0) {
                    container.innerHTML = `
                        <div style="text-align: center; padding: 3rem; grid-column: 1 / -1;">
                            <i class="fas fa-book" style="font-size: 4rem; color: var(--text-gray); margin-bottom: 1rem;"></i>
                            <h3>No books in library yet</h3>
                            ${currentUser.role === 'admin' ? `
                                <div style="margin-top: 1rem;">
                                    <button class="btn btn-primary" onclick="openAddBookModal()">
                                        <i class="fas fa-plus"></i> Add Single Book
                                    </button>
                                    <button class="btn" onclick="openBatchUpload()" style="margin-left: 10px; background: var(--neon-green); color: var(--dark-bg);">
                                        <i class="fas fa-upload"></i> Batch Upload
                                    </button>
                                </div>
                            ` : '<p>Check back soon for new additions!</p>'}
                        </div>
                    `;
                    hideLoading();
                    return;
                }
                
                // Display all books (no search filter)
                displaySearchResults(allBooks);
                
                hideLoading();
                
            } catch (error) {
                console.error('Error loading books:', error);
                container.innerHTML = `
                    <div style="text-align: center; padding: 3rem; color: #ff3860;">
                        <i class="fas fa-exclamation-triangle fa-2x"></i>
                        <h3>Error loading books</h3>
                        <p>${error.message}</p>
                    </div>
                `;
                hideLoading();
            }
        }

        // Update the handleAddBook function to use compression
        async function handleAddBook(event) {
            event.preventDefault();
            
            // ... (previous validation code remains the same)
            
            try {
                // Show loading
                showLoading('Compressing and uploading PDF...', 'This may take a moment for large files');
                
                // Get compression level from UI (add this to your add book modal)
                const compressionLevel = document.getElementById('compressionLevel')?.value || 50;
                
                // Compress and save PDF
                const compressionResult = await storage.saveCompressedPDF(
                    Date.now(),
                    pdfFile,
                    compressionLevel
                );
                
                // Create book with compression info
                const newBook = {
                    id: Date.now(),
                    title: title,
                    author: author,
                    category: category,
                    description: description || `A book about ${title}`,
                    hasPdf: true,
                    pdfId: compressionResult.pdfId,
                    dateAdded: new Date().toLocaleDateString(),
                    addedBy: currentUser.name || "Admin",
                    uploadDate: new Date().toISOString(),
                    fileSize: storage.formatBytes(pdfFile.size),
                    compressionInfo: {
                        originalSize: compressionResult.stats.originalSize,
                        compressedSize: compressionResult.stats.compressedSize,
                        savings: compressionResult.stats.savings
                    }
                };
                
                // Save book metadata
                await storage.saveBook(newBook);
                
                // Update search index
                await storage.buildSearchIndex();
                
                // Show success with compression stats
                const savedSpace = storage.formatBytes(
                    compressionResult.stats.originalSize - compressionResult.stats.compressedSize
                );
                
                showAlert(
                    `âœ… "${title}" added successfully!<br>
                    Compression saved ${savedSpace} (${compressionResult.stats.savings})`,
                    'success'
                );
                
                // Close modal and refresh
                closeModal('addBookModal');
                await loadBooks();
                
            } catch (error) {
                showAlert('Error: ' + error.message, 'error');
                console.error('Upload error:', error);
            } finally {
                hideLoading();
            }
        }

        // ===== UPDATE INITIALIZATION =====
        document.addEventListener('DOMContentLoaded', async function() {
            // Initialize enhanced storage
            await initializeEnhancedStorage();
            
            // Rest of your existing initialization code...
            // (Load user, set up navigation, etc.)
        });

        // ===== ADD BATCH UPLOAD BUTTON TO ADMIN CONTROLS =====
        function updateLibraryControls() {
            const controls = document.getElementById('libraryControls');
            if (!controls) return;
            
            if (currentUser.role === 'admin') {
                controls.innerHTML = `
                    <div style="display: flex; gap: 10px; flex-wrap: wrap; justify-content: center;">
                        <button class="btn btn-primary" onclick="openAddBookModal()">
                            <i class="fas fa-plus"></i> Add Single Book
                        </button>
                        <button class="btn" onclick="openBatchUpload()" style="background: var(--neon-green); color: var(--dark-bg);">
                            <i class="fas fa-upload"></i> Batch Upload (Up to 50)
                        </button>
                        <button class="btn" onclick="showStorageStats()" style="background: var(--spark-purple); color: white;">
                            <i class="fas fa-chart-pie"></i> Storage Stats
                        </button>
                    </div>
                    <p style="margin-top: 1rem; color: var(--text-gray); text-align: center;">
                        <i class="fas fa-info-circle"></i> Library with compression & search - ${books.length} books
                    </p>
                `;
            } else {
                controls.innerHTML = `
                    <p>Welcome to our enhanced library! ${books.length} books available with smart search.</p>
                    ${currentUser.isLoggedIn ? `
                        <p style="color: var(--text-gray); margin-top: 0.5rem;">
                            <i class="fas fa-search"></i> Use search bar to find books quickly
                        </p>
                    ` : ''}
                `;
            }
        }

        // ===== STORAGE STATS FUNCTION =====
        async function showStorageStats() {
            if (!storage) return;
            
            try {
                showLoading('Calculating storage statistics...');
                
                const stats = await storage.getStorageStats();
                const usedSpace = storage.formatBytes(stats.totalCompressedSize);
                const savedSpace = storage.formatBytes(stats.spaceSaved);
                
                let message = `
                    <strong>Storage Statistics:</strong><br><br>
                    â€¢ Total Books: ${stats.totalBooks}<br>
                    â€¢ Used Space: ${usedSpace}<br>
                    â€¢ Space Saved: ${savedSpace}<br>
                    â€¢ Compression Rate: ${stats.compressionRate}%<br><br>
                    <small style="color: var(--text-gray);">
                        <i class="fas fa-lightbulb"></i> 
                        Compression reduces file sizes while maintaining quality
                    </small>
                `;
                
                hideLoading();
                showAlert(message, 'info');
                
            } catch (error) {
                hideLoading();
                showAlert('Error getting storage stats: ' + error.message, 'error');
            }
        }

        // ===== ADD COMPRESSION CONTROL TO ADD BOOK MODAL =====
        function openAddBookModal() {
            // Your existing code to open modal...
            
            // Add compression controls to the modal
            const form = document.getElementById('addBookForm');
            if (form && !form.querySelector('#compressionLevel')) {
                const compressionHTML = `
                    <div class="compression-controls" style="margin: 1rem 0;">
                        <label style="display: block; margin-bottom: 0.5rem;">
                            <i class="fas fa-compress-arrows-alt"></i> PDF Compression
                        </label>
                        <input type="range" min="0" max="100" value="50" 
                               class="compression-slider" id="compressionLevel">
                        <div class="compression-info">
                            <span>Best Quality</span>
                            <span id="compressionValue">50%</span>
                            <span>Smallest Size</span>
                        </div>
                        <div class="compression-preview" id="compressionPreview">
                            Estimated savings: <span id="estimatedSavings">0%</span>
                        </div>
                    </div>
                `;
                
                // Insert before the submit button
                const submitBtn = form.querySelector('button[type="submit"]');
                if (submitBtn) {
                    submitBtn.insertAdjacentHTML('beforebegin', compressionHTML);
                }
                
                // Setup compression slider
                const slider = document.getElementById('compressionLevel');
                const valueDisplay = document.getElementById('compressionValue');
                const preview = document.getElementById('compressionPreview');
                const estimatedSavings = document.getElementById('estimatedSavings');
                
                if (slider) {
                    slider.addEventListener('input', function(e) {
                        const value = parseInt(e.target.value);
                        valueDisplay.textContent = `${value}%`;
                        
                        // Show estimated savings
                        const savings = Math.round(value * 0.8); // Simple estimation
                        estimatedSavings.textContent = `${savings}%`;
                        preview.classList.add('active');
                    });
                    
                    // Update on file selection
                    const fileInput = document.getElementById('bookPdfFile');
                    if (fileInput) {
                        fileInput.addEventListener('change', function(e) {
                            if (e.target.files[0]) {
                                preview.classList.add('active');
                            }
                        });
                    }
                }
            }
        }
    </script>
</body>
</html>
